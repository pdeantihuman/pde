# Docker Storage Driver

为了有效地使用存储驱动程序，了解Docker如何构建和存储 image 以及容器如何使用这些 image 非常重要。您可以使用这些信息做出明智的选择，选择保存应用程序中数据的最佳方式，并在此过程中避免性能问题。

存储驱动程序允许您在容器的可写层中创建数据。删除容器后，文件将不会持久化，读写速度都低于本机文件系统性能。

注意:已知有问题的操作包括写密集型数据库存储，尤其是当只写层中存在预先存在的数据时。本文提供了更多详细信息。

了解如何使用卷来保存数据和提高性能。

## 镜像和层

Docker image 是由一系列层构成的。每一层都代表 image 文件中的一条指令。除了最后一层之外，每一层都是只读的。考虑以下文件:

```dockerfile
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
```

该文件包含四个命令，每个命令创建一个层。FROM语句从ubuntu:18.04 image 创建一个层开始。COPY命令从Docker客户端的当前目录中添加一些文件。RUN命令使用make命令构建应用程序。最后，最后一层指定在容器中运行什么命令。

每一层与它之前的层只是一组差异。这些层堆叠在一起。创建新容器时，会在基础层上添加一个新的可写层。这一层通常被称为“容器层”。对正在运行的容器所做的所有更改，如写入新文件、修改现有文件和删除文件，都将写入该可写容器薄层。下图显示了一个基于Ubuntu 18.04 image 的容器。

存储驱动程序处理这些层相互作用的细节。有不同的存储驱动程序，它们在不同的情况下各有利弊。

## 容器和层

容器和 image 的主要区别是顶部可写层。添加新数据或修改现有数据的对容器的所有写入都存储在该可写层中。删除容器时，可写层也将被删除。底层 image 保持不变。

因为每个容器都有自己的可写容器层，并且所有的更改都存储在这个容器层中，所以多个容器可以共享对同一基础镜像的访问，但又有自己的数据状态。下图显示了共享同一个Ubuntu 18.04镜像的多个容器。

这个可写容器层被称为一个 Thin R/W Layer。

> 如果您需要多个镜像共享访问完全相同的数据，请将这些数据存储在Docker卷中，并将其装载到您的容器中。

Docker使用存储驱动程序来管理镜像层和可写容器层的内容。每个存储驱动程序处理实现的方式不同，但是所有驱动程序都使用可堆叠的镜像层和写时拷贝(CoW)策略。

## 容器在硬盘上的体积

要查看正在运行的容器的大致大小，可以使用docker ps -s命令。两个不同的列与大小有关。

- `size` : 用于每个容器的可写层的数据量(磁盘上)。

- `virtual size` : 容器使用的只读镜像数据的数据量加上容器的可写层`size`。多个容器可以共享部分或全部只读镜像数据。从同一个镜像开始的两个容器共享100%的只读数据，而具有不同镜像且具有共同层的两个容器共享这些共同层。因此，您不能只计算虚拟大小的总和。这可能高估了磁盘的总使用量。

磁盘上所有正在运行的容器使用的总磁盘空间是每个容器 `size` 和 `virual size` 值的某种组合。如果多个容器是从同一个镜像开始，这些容器在磁盘上的总大小将是SUM(容器`size`)加上一个镜像大小(`virtual size`)。

这还不包括容器占用磁盘空间的以下额外方式:

- 如果使用`json-file`日志驱动程序，用于日志文件的磁盘空间。如果您的容器生成大量日志数据并且没有配置日志轮换，这可能不是小事。

- 容器使用的卷和bind挂载。
- 用于容器配置文件的磁盘空间，通常很小。
- 写入磁盘的内存(如果启用了交换)。
- 检查点，如果您正在使用实验性检查点/恢复功能。

## 写时拷贝cow策略

写时拷贝是一种共享和拷贝文件以获得最高效率的策略。如果一个文件或目录存在于镜像的较低层，而另一个层(包括可写层)需要对其进行读访问，则它只使用现有文件。第一次另一层需要修改文件时(当构建镜像或运行容器时)，文件被复制到该层并被修改。这最小化了输入/输出和每个后续层的大小。这些优势将在下面更深入地解释。

当您使用 `docker pull` 从仓库中下拉镜像时，或者当您从本地尚不存在的镜像创建容器时，每一层都被单独下拉，并存储在Docker的本地存储区中，该存储区通常位于/var/lib/Docker/Linux主机上。在本例中，您可以看到这些层被拉动:

## 复制使容器高效

启动容器时，一个薄的可写容器层会添加到其他层的顶部。容器对文件系统所做的任何更改都存储在这里。容器未更改的任何文件都不会复制到该可写层。这意味着可写层尽可能小。

当修改容器中的现有文件时，存储驱动程序执行写时复制操作。涉及的具体步骤取决于特定的存储驱动程序。对于aufs、overlay和overlay2驱动程序，写入时复制操作遵循以下粗略顺序:

- 在镜像层中搜索要更新的文件。该过程从最新的层开始，一次一层地向下进行到基础层。当发现结果时，它们会被添加到缓存中，以加速未来的操作。

- 对找到的文件的第一个副本执行`copy up`操作，将文件复制到容器的可写层。
- 对此文件的副本进行任何修改，并且容器看不到存在于下层的文件的只读副本。

Btrfs、ZFS和其他驱动程序对写入时复制的处理方式不同。稍后，您可以在这些驱动程序的详细描述中了解更多关于这些驱动程序的方法。

写大量数据的容器比不写数据的容器消耗更多的空间。这是因为大多数写操作消耗容器的薄可写顶层中的新空间。

> 对于写密集型应用程序，不应该将数据存储在容器中。相反，请使用Docker Volume，该卷独立于正在运行的容器，并且被设计为可以高性能输入/输出。此外，卷可以在容器之间共享，并且不会增加容器的可写层的大小。

`copy up`操作会导致明显的性能开销。这种开销因使用的存储驱动程序而异。大型文件、许多层和深层目录树会使影响更加明显。事实上，每个复制操作只在给定文件第一次被修改时才发生，这缓解了这种情况。

为了验证写时复制的工作方式，以下过程基于`acme/my-final-image:1.0` 映像旋转5个容器，并检查它们占用了多少空间。

> 此过程不适用于桌面版。

1. 从Docker宿主机上的终端运行以下 Docker `Run`命令。末尾的字符串是每个容器的标识。

   ```bash
   docker run -dit --name my_container_1 acme/my-final-image:1.0 bash \
     && docker run -dit --name my_container_2 acme/my-final-image:1.0 bash \
     && docker run -dit --name my_container_3 acme/my-final-image:1.0 bash \
     && docker run -dit --name my_container_4 acme/my-final-image:1.0 bash \
     && docker run -dit --name my_container_5 acme/my-final-image:1.0 bash
   ```

2. 运行docker ps命令，验证5个容器是否正在运行。

3. 列出本地存储区域的内容。

   ```bash
   sudo ls /var/lib/docker/containers
   ```

4. 检查他们的体积

   ```bash
   sudo du -sh /var/lib/docker/containers/*
   ```

写时拷贝不仅节省了空间，还缩短了启动时间。当您启动一个容器(或同一镜像中的多个容器)时，Docker只需要创建薄的可写容器层。

如果Docker每次启动新容器时都必须制作底层镜像堆栈的完整副本，那么容器启动时间和所用磁盘空间将会显著增加。这类似于虚拟机的工作方式，每个虚拟机有一个或多个虚拟磁盘。

## 选择 Docker 的存储驱动

理想情况下，很少数据被写入容器的可写层，您可以使用Docker卷来写入数据。但是，有些工作负载要求您能够写入容器的可写层。这是存储驱动程序的切入点。

Docker使用可插拔架构支持几种不同的存储驱动程序。存储驱动程序控制镜像和容器在归档主机上的存储和管理方式。

阅读存储驱动程序概述后，下一步是为您的工作负载选择最佳的存储驱动程序。在做出这一决定时，需要考虑三个高级因素:

如果内核支持多个存储驱动程序，Docker有一个优先级列表，列出在没有明确配置存储驱动程序的情况下使用哪个存储驱动程序，前提是存储驱动程序满足先决条件。

在最常见的情况下，使用具有最佳整体性能和稳定性的存储驱动程序。

Docker支持以下存储驱动程序:

1. 对于所有当前支持的Linux发行版，overlay2是首选的存储驱动程序，不需要额外的配置。
2. aufs是Docker 18.06和更老版本的首选存储驱动程序，当运行在Ubuntu 14.04内核3.13上时，内核3.13不支持覆盖2。
3. Docker支持`devicemapper`，但生产环境需要`direct-lvm`，因为loopback-lvm虽然为零配置，但性能非常差。devicemapper是CentOS和RHEL推荐的存储驱动程序，因为它们的内核版本不支持重叠2。但是，当前版本的CentOS和RHEL现在支持overlay2，这是现在推荐的驱动程序。
4. 如果btrfs和zfs存储驱动程序是后备文件系统(安装Docker的主机的文件系统)，则使用它们。这些文件系统允许高级选项，例如创建“快照”，但是需要更多的维护和设置。这些都依赖于备份文件系统的正确配置。
5. vfs存储驱动程序旨在用于测试目的，以及不能使用写时复制文件系统的情况。此存储驱动程序的性能很差，一般不推荐用于生产。

Docker 的源代码定义了选择顺序。您可以在Docker引擎-社区19.03的源代码中看到订单

如果运行不同版本的Docker，可以使用文件查看器顶部的分支选择器来选择不同的分支。

一些存储驱动程序要求您为备份文件系统使用特定的格式。如果您有使用特定备份文件系统的外部要求，这可能会限制您的选择。请参见支持的备份文件系统。

缩小您可以选择的存储驱动程序范围后，您的选择取决于您的工作负载特征和所需的稳定性级别。有关做出最终决定的帮助，请参见其他注意事项。