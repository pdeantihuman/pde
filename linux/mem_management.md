# Linux 内存管理

内核内部的内存分配不如内核外部的内存分配简单。简而言之，内核缺乏用户空间享受的奢侈品。
与用户空间不同，内核并不总是能够轻松分配内存。例如，内核不容易处理内存分配错误，并且内核经常无法睡眠。
由于这些限制，以及对轻量级内存分配方案的需求，在内核中获取内存比在用户空间中获取内存要复杂得多。这并不是说，从程序员的角度来看，内核内存分配很困难——只是不同而已。

本章讨论用于获取内核内存的方法。然而，在深入研究实际的分配接口之前，您需要了解内核是如何处理内存的。

## 页

内核将物理页视为内存管理的基本单元。
虽然处理器最小的可寻址单元是一个字节或一个字，但内存管理单元(内存管理单元，管理内存并执行虚拟到物理地址转换的硬件)通常以页为单位进行处理。
因此，MMU以页大小的粒度维护系统的页表(因此得名)。就虚拟内存而言，页是最重要的最小单位。

如您在第19章“可移植性”中所见，每个体系结构都定义了自己的页大小。许多架构甚至支持多种页大小。大多数32位体系结构有4KB页，而大多数64位体系结构有8KB页。这意味着在具有4KB页和1GB内存的机器上，物理内存被分成262，144个不同的页。
内核用结构化页结构表示系统中的每个物理页。该结构在 `<Linux/mm_type.h>` 中定义。我简化了定义，去掉了两个令人困惑的联合，这两个联合无助于我们对基础知识的讨论:

```c
struct page {
    unsigned long   flags;
    atomic_t        _count;
    atomic_t        _mapcount;
    unsigned long   private;
    struct address_space *mapping;
    pgoff_t         index;
    struct list_head lru;
    void*           virtual;
}
```

让我们看看重要的字段。`flags`字段存储页的状态。这些标志包括页是否脏或者是否被锁定在内存中。位标志代表不同的值，因此至少有32个不同的标志同时可用。标记值在`<linux/page-flags.h>`中定义。

`_count`字段存储页的使用计数，即该页有多少引用。当该计数达到负1时，没有人正在使用该页，并且该页可用于新的分配。内核代码不应该直接检查这个字段，而是应该使用`page_count()`函数，它将页结构作为唯一的参数。虽然当页空闲时内部计数为负1，但`page_count()`返回零表示空闲，当页正在使用时返回非零正整数。页缓存可以使用页(在这种情况下，映射字段指向与该页相关联的地址空间对象)、作为私有数据(由私有对象指向)或作为进程页表中的映射。

`virtual`字段是页的虚拟地址。通常，这只是虚拟内存中页的地址。一些内存(称为高内存)不会永久映射到内核的地址空间中。在这种情况下，该字段为空，如果需要，页必须动态映射。我们将很快讨论高记忆。

需要理解的重要一点是，页结构与物理页相关联，而不是虚拟页。因此，该结构描述的充其量只是暂时的。即使页中包含的数据继续存在，由于交换等原因，它可能并不总是与相同的页结构相关联。内核使用这个数据结构来描述相关的物理页。数据结构的目标是描述物理内存，而不是其中包含的数据。

内核使用这种结构来跟踪系统中的所有页，因为内核需要知道一个页是否空闲(也就是说，该页是否未被分配)。如果一个页不是自由的，内核需要知道谁拥有这个页。可能的所有者包括用户空间进程、动态分配的内核数据、静态内核代码、页缓存等等。

开发人员经常惊讶于这种结构的一个实例被分配给系统中的每个物理页。他们想，“浪费了多少记忆！”让我们看看这些页的空间消耗有多糟糕(或多好)。假设结构页消耗40字节的内存，系统有8KB的物理页，系统有4GB的物理内存。在这种情况下，系统上大约有524，288个页和页结构。页结构消耗20MB:从绝对值来看，这可能是一个惊人的大数字，但相对于系统4GB来说，这只是一小部分——管理系统所有物理页的成本并不太高。

## Zones

由于硬件限制，内核不能将所有页面都视为相同的。由于内存中的物理地址，有些页面不能用于某些任务。由于这个限制，内核将页面分成不同的区域。内核使用这些区域来对具有相似属性的页面进行分组。特别是，在内存寻址方面，Linux必须解决硬件的两个缺点:

一些硬件设备只能对特定的内存地址执行直接内存访问。

一些体系结构可以物理寻址比实际寻址更多的内存。因此，一些内存不会永久映射到内核地址空间。

由于这些限制，Linux有四个主要的内存区域:

- `ZONE_DMA`这个区域包含可以进行DMA的页面。
- `ZONE_DMA32`—与ZOME_DMA一样，该区域包含可以进行直接内存访问的页面。与`ZONE_DMA`不同，这些页面只能由32位设备访问。在某些架构中，这个区域是内存的一个较大子集。
- `ZONE_NORMAL`—此区域包含正常、规则映射的页面。
- `ZONE_HIGHMEM`—该区域包含“高内存”，即页面不是永久性的动态映射到内核的地址空间。

在 `<linux/mmzone.h>`中定义了这些区域和另外两个不太引人注目的区域。

存储区的实际使用和布局取决于体系结构。例如，一些架构对任何内存地址执行直接内存分配没有问题。在这些体系结构中，`ZONE_DMA`为空，`ZONE_NORMAL`用于分配，而不管它们的用途如何。作为反例，在x86体系结构上，ISA设备不能对完整的32位地址空间1执行直接内存分配，因为ISA设备只能访问前16MB的物理内存。因此，x86上的`ZONE_DMA`由0MB到16MB范围内的所有内存组成。

`ZONE_HIGHMEM`在同样的方面工作。一个架构可以和不可以直接映射的内容各不相同。在32位x86系统上，`ZONE_HIGHMEM`是物理896兆字节标记以上的所有内存


