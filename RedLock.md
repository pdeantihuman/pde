# RedLock: Redis 分布式锁的推荐实现

分布式锁在许多环境中是非常有用的原语，在这些环境中，不同的进程必须以互斥的方式使用共享资源进行操作。

有许多库和博客文章描述了如何用Redis实现DLM(分布式锁管理器)，但是每个库都使用不同的方法，许多库使用的简单方法与稍微复杂一些的设计相比，保证更低。
此页面试图提供一个更规范的算法来实现带有Redis的分布式锁。我们提出了一种叫做Redlock的算法，它实现了一个我们认为比普通的单实例方法更安全的DLM。我们希望社区能够对其进行分析，提供反馈，并将其作为实施或更复杂或替代设计的起点。

## 实现

在描述算法之前，这里有几个已经可用的实现的链接可供参考。
- Redlock-rb (Ruby实现)。还有一个Redlock-rb的fork，它添加了一个gem，便于分发，可能还有更多fork。
- Redlock-py (Python实现)。
- Aioredlock (Asyncio Python实现)。
- Redlock-php (PHP实现)。
- 进一步的PHP实现
		○ cheprasov/php-redis-lock(用于锁的php库)
- RedSync(Go实现)。
- Redisson (Java实现)。
- Redis::DistLock (Perl实现)。
- Redlock-cpp (C++实现)。
- Redlock-cs (C#/)。NET实现)。
- RedLock.net(c#/。NET实现)。包括异步和锁的扩展支持。
- ScarletLock (C#)。NET实现，具有可配置的数据存储)
- Redlock4Net (C#。NET实现)
- node-redlock (NodeJS实现)。包括对锁扩展的支持。
## 安全性和活性保证
我们将用三个属性来建模我们的设计，在我们看来，这三个属性是有效使用分布式锁所需的最低保证。
- 安全属性:互斥。在任何给定的时刻，只有一个客户端可以持有锁。
- 活性属性1:无死锁。最终，即使锁定资源的客户端崩溃或被分区，也总是有可能获得锁。
- 活性特性2:容错。只要大多数Redis节点启动，客户端就能够获取和释放锁。

为什么基于故障转移的实现还不够

为了理解我们想要改进什么，让我们分析大多数基于Redis的分布式锁库的当前状态。

使用Redis锁定资源的最简单方法是在实例中创建一个键。密钥通常是在有限的生存时间内创建的，使用Redis expires特性，因此最终它将被释放(活性特性1)。当客户端需要释放资源时，它会删除密钥。

表面上看，这很好，但是有一个问题:这是我们架构中的一个单点故障。如果Redis Master倒下了会发生什么？好吧，让我们增加一个Slave！如果Master不可用，请使用它。不幸的是，这是不可行的。这样做，我们就不能实现互斥的安全属性，因为Redis复制是异步的。

这个模型有一个明显的竞争条件:

1. 客户端获取主服务器中的锁。
2. 在将密钥写入传输到从机之前，主机崩溃。
3. 奴隶被提升为主人。
4. 客户端B获取对同一资源的锁，而资源A已经持有对的锁。违反安全规定！

有时，在特殊情况下，比如在故障期间，多个客户端可以同时持有锁是非常好的。如果是这种情况，您可以使用基于复制的解决方案。否则，我们建议实施本文档中描述的解决方案。

### 使用单个实例正确实现

在试图克服上面描述的单个实例设置的限制之前，让我们检查一下在这个简单的例子中如何正确地完成它，因为这实际上是一个可行的解决方案，在应用程序中，有时竞争条件是可接受的，并且因为锁定在单个实例中是我们将用于这里描述的分布式算法的基础。

获取锁的方法如下:
```
	SET resource_name my_random_value NX PX 30000
```
只有当密钥不存在时(NX选项)，命令才会设置密钥，过期时间为30000毫秒(PX选项)。该键被设置为值“myrandomvalue”。该值在所有客户端和所有锁定请求中必须是唯一的。

基本上，使用随机值是为了以安全的方式释放锁，脚本告诉Redis:只有当密钥存在并且存储在密钥中的值正是我期望的值时，才移除密钥。这是通过以下Lua脚本实现的:

```lua
if redis.call("get",KEYS[1]) == ARGV[1] 
then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

这对于避免移除由另一个客户端创建的锁很重要。例如，客户端可能获取锁，在某些操作中被阻止的时间超过锁的有效时间(密钥将过期的时间)，然后移除已经被其他客户端获取的锁。仅使用DEL是不安全的，因为客户端可能会移除另一个客户端的锁。相反，使用上面的脚本，每个锁都是用随机字符串“签名”的，所以只有当它仍然是客户端试图移除它时，锁才会被移除。

这个随机字符串应该是什么？我假设它是来自/dev/urandom的20个字节，但是你可以找到更便宜的方法使它对于你的任务足够独特。例如，一个安全的选择是用/dev/urandom为RC4生成种子，并从中生成伪随机流。一个更简单的解决方案是使用unix时间和微秒分辨率的组合，将其与客户端标识连接起来，这并不安全，但在大多数环境中可能可以胜任任务。

我们用时间作为生命周期的关键时间，叫做“锁有效期”。这既是自动释放时间，也是客户端在另一个客户端能够再次获取锁之前执行所需操作的时间，而不会在技术上违反互斥保证，互斥保证只限于从获取锁开始的给定时间窗口。

所以现在我们有了一个获取和释放锁的好方法。该系统是安全的，推理中假设的非分布式系统由一个单一的，总是可用的实例组成。让我们将这个概念扩展到一个没有这种保证的分布式系统。

## 红锁RedLock算法

在该算法的分布式版本中，我们假设我们有N个Redis主机。这些节点是完全独立的，所以我们不使用复制或任何其他隐式协调系统。我们已经描述了如何在单个实例中安全地获取和释放锁。我们想当然地认为算法将使用这种方法在单个实例中获取和释放锁。在我们的示例中，我们设置了N=5，这是一个合理的值，因此我们需要在不同的计算机或虚拟机上运行5个Redis主机，以确保它们以一种基本独立的方式失败。

为了获取锁，客户端执行以下操作:

1. 它以毫秒为单位获取当前时间。
2. 它试图在所有的N个实例中顺序获取锁，在所有实例中使用相同的键名和随机值。
{% hint style="info" %}
在步骤2中，当在每个实例中设置锁时，客户端使用的超时时间比获取锁的总自动释放时间小。例如，如果自动释放时间为10秒，超时时间可能在约5-50毫秒范围内。这可以防止客户端在很长一段时间内试图与关闭的Redis节点进行通信时被阻止:如果一个实例不可用，我们应该尽快尝试与下一个实例进行通信。
{% endhint %}
3. 客户端通过从当前时间中减去步骤1中获得的时间戳来计算获取锁所用的时间。如果且仅当客户端能够在大多数实例(至少3个)中获取锁，并且获取锁所用的总时间小于锁的有效时间时，则该锁被视为已获取。
{% hint style="info" %}
如果锁被获取，其有效时间被认为是初始有效时间减去经过的时间，如步骤3中所计算的。
{% endhint %}
如果客户端由于某种原因未能获得锁(或者无法锁定$N/2+1$个实例，或者有效时间为负)，它将尝试解锁所有实例(甚至是它认为无法锁定的实例)。

### 算法是异步的吗？

该算法依赖于这样的假设，即尽管进程之间没有同步时钟，但每个进程中的本地时间仍然以大致相同的速率流动，与锁的自动释放时间相比，误差较小。这个假设非常类似于现实世界中的计算机:每台计算机都有一个本地时钟，我们通常可以依靠不同的计算机来获得较小的时钟漂移。

在这一点上，我们需要更好地指定互斥规则:只有当持有锁的客户端在锁有效时间(如步骤3中获得的)减去一些时间(仅几毫秒以补偿进程之间的时钟漂移)内终止其工作时，互斥规则才能得到保证。

有关需要绑定时钟漂移的类似系统的更多信息，本文是一篇有趣的参考文章:租约:分布式文件缓存一致性的高效容错机制。

### 失败时重试

当一个客户端无法获取锁时，它应该在随机延迟后重试，以便尝试使试图同时获取同一资源锁的多个客户端去同步(这可能导致没有人获胜的分裂大脑情况)。此外，在大多数Redis实例中，客户端获取锁的速度越快，裂脑情况的窗口越小(以及重试的需要)，因此理想情况下，客户端应该尝试使用多路复用同时向N个实例发送SET命令。

值得强调的是，对于无法获取大部分锁的客户端来说，尽快释放(部分)获取的锁非常重要，因此无需等待密钥到期才能再次获取锁(但是，如果发生网络分区，并且客户端不再能够与Redis实例通信，则在等待密钥到期时会有可用性损失)。

### 释放锁

释放锁很简单，只需要在所有实例中释放锁，无论客户端是否认为它能够成功锁定给定的实例。

### 安全论据

算法安全吗？我们可以试着理解在不同的场景中会发生什么。

首先，让我们假设客户端能够在大多数情况下获得锁。所有实例都将包含一个具有相同生存时间的密钥。但是，密钥是在不同的时间设置的，因此密钥也将在不同的时间到期。但是，如果第一个密钥在时间T1(联系第一个服务器之前我们采样的时间)被设置为最差，而最后一个密钥在时间T2(我们从最后一个服务器获得回复的时间)被设置为最差，那么我们可以确定，该集合中第一个过期的密钥将至少存在MIN _ VALITY = TTL-(T2-T1)-CLOCK _漂移。所有其他密钥都将在稍后过期，因此我们确信这些密钥至少这次会同时设置。

在设置大部分密钥期间，另一个客户端将无法获取锁，因为如果已经存在N/2+1个密钥，则N/2+1个设置NX操作不会成功。因此，如果获得了锁，就不可能同时重新获得它(违反互斥属性)。

然而，我们也希望确保多个试图同时获取锁的客户端不能同时成功。

如果客户端锁定大多数实例的时间接近或大于锁定最大有效时间(基本上是我们用于SET的TTL)，它将认为锁定无效并将解锁实例，因此我们只需要考虑客户端能够在小于有效时间的时间内锁定大多数实例的情况。在这种情况下，对于上面已经表达的参数，对于MIN _ VALIDITY，没有客户端能够重新获取锁。因此，只有当锁定大多数实例的时间大于TTL时间时，多个客户端才能同时锁定N/2+1个实例(步骤2的结尾是“时间”)，从而使锁定无效。

你能提供安全的正式证明，指出相似的现有算法，或者发现一个错误吗？非常感谢。

## 活性的证明

系统活性基于三个主要特征:
1. 锁的自动释放(自钥匙到期后):最终钥匙可再次被锁定。
2. 事实上，客户端通常会在锁未被获取时，或者当锁被获取且工作终止时合作移除锁，这使得我们不必等待密钥过期来重新获取锁。
3. 当客户端需要重试锁时，它等待的时间比获取大多数锁所需的时间要长，以便在资源争用期间不太可能出现大脑分裂的情况。
但是，我们在网络分区上支付的可用性代价等于TTL时间，所以如果有连续的分区，我们可以无限期地支付这个代价。每当客户端获取锁并在能够移除锁之前被分区时，都会发生这种情况。

基本上，如果有无限连续的网络分区，系统可能会在无限长的时间内不可用。

## 性能、故障恢复和fsync

许多使用Redis作为锁服务器的用户需要高性能，包括获取和释放锁的延迟，以及每秒可以执行的获取/释放操作的数量。为了满足这一要求，与N Redis服务器进行通信以减少延迟的策略肯定是多路复用(或穷人的多路复用，即把套接字置于非阻塞模式，发送所有命令，并在以后读取所有命令，假设客户机和每个实例之间的RTT相似)。
然而，如果我们想要以崩溃恢复系统模型为目标，关于持久性还有另一个需要考虑的问题。

从根本上看，这里的问题是，让我们假设我们配置了Redis而没有持久性。客户端在5个实例中的3个实例中获取锁。客户端能够获取锁的一个实例被重新启动，此时，我们可以为同一资源锁定3个实例，另一个客户端可以再次锁定它，这违反了锁的排他性的安全属性。

如果我们启用AOF持久性，情况将会有很大改善。例如，我们可以通过发送SHUTDOWN并重新启动来升级服务器。因为Redis过期是语义实现的，所以当服务器关闭时，实际上时间仍然在流逝，所以我们所有的需求都很好。然而，只要是干净的关机，一切都很好。停电怎么样？如果Redis默认配置为每秒在磁盘上进行fsync，重启后可能会丢失密钥。理论上，如果我们想要在任何类型的实例重启时保证锁的安全性，我们需要在持久性设置中启用fsync =始终。这反过来会完全破坏传统上用于以安全方式实现分布式锁的相同级别的CP系统的性能。

然而，事情比乍看上去要好。基本上，只要一个实例在崩溃后重新启动，它就不再参与任何当前活动的锁，因此当实例重新启动时，当前活动的锁的集合都是通过锁定除了重新加入系统的实例之外的实例来获得的。

为了保证这一点，我们只需要使一个实例在崩溃后不可用，至少比我们使用的最大TTL多一点，也就是说，当实例崩溃时存在的锁的所有密钥所需的时间变得无效并被自动释放。

使用延迟重启基本上可以实现安全性，即使没有任何类型的Redis持久性可用，但是请注意，这可能会转化为可用性损失。例如，如果大多数实例崩溃，系统对于TTL将变得全局不可用(这里全局意味着在此期间根本没有资源可锁定)。

使算法更加可靠:扩展锁

如果客户端执行的工作由小步骤组成，默认情况下可以使用较小的锁有效时间，并扩展实现锁扩展机制的算法。基本上，如果在计算过程中，当锁的有效性接近低值时，客户端可以通过向所有实例发送Lua脚本来扩展锁，如果密钥存在并且其值仍然是客户端在获取锁时分配的随机值，则该脚本扩展密钥的TTL。

只有当客户端能够在有效时间内将锁扩展到大多数实例中时，才应该考虑重新获取锁(基本上要使用的算法与获取锁时使用的算法非常相似)。

然而，这在技术上并没有改变算法，因此应该限制锁重新获取尝试的最大次数，否则会违反其中一个活跃度属性。

想帮忙吗？

如果你对分布式系统感兴趣，最好能得到你的意见/分析。另外，其他语言的引用实现也可能很棒。

提前谢谢！

红锁分析
马丁·克莱普曼在这里分析了雷德洛克。我不同意这一分析，并将我对他分析的回复贴在这里。


