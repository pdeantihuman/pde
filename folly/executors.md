# Executors

Wangle提供了两个具体的线程池(IOThreadPoolExecutor、CPUThreadPoolExecutor)，并将其作为完整异步框架的一部分构建。一般来说，您可能想要获取全局执行器，并将其用于未来，如下所示:

```cpp
auto f = someFutureFunction().via(getCPUExecutor()).then(...)
```

或者，您可能需要构建一个thrift/memcache客户端，并需要一个事件库:

```cpp
auto f = getClient(getIOExecutor()->getEventBase())->callSomeFunction(args...)
         .via(getCPUExecutor())
         .then([](Result r){ .... do something with result});

```

## 与 `std::launch` 的区别 

当前的C++11 std::launch只有两种模式:异步或延迟。在生产系统中，这也不是您想要的:async将在每次启动时无限制地启动一个新线程，而deferred会将工作延迟到需要时，然后在需要时同步地在当前线程中执行工作。

Wangle的线程池总是尽可能快地启动工作，对允许的最大任务/线程数量有限制，所以我们永远不会使用超过绝对需要的线程。参见下面关于每种执行器类型的实现细节。

## 为什么我们还需要另一组线程池？

不幸的是，现有的线程池都没有所需的所有功能——基于管道的事情太慢了。几个旧的不支持`std::function`。

## 为什么我们需要几种不同类型的线程池？

如果您想要epoll支持，您需要一个fd - event_fd是最新的通知热点。不幸的是，一个活动的fd触发了它所在的所有epoll循环，导致了雷鸣般的群发——所以如果你想要一个公平的队列(一个队列全部vs每个工作线程一个队列)，你需要使用某种信号量。不幸的是，信号量不能放在epoll循环中，所以它们与输入输出不兼容。幸运的是，无论如何，您通常都希望将输入输出和CPU绑定的工作分开，以便在输入输出上提供更强的尾部延迟保证。

## IOThreadPoolExecutor

- 使用`event_fd`进行通知，并唤醒epoll循环。
- 每个`thread/epoll`有一个队列(特别是通知队列`NotificationQueue`)。
- 如果线程已经在运行，并且没有在等待epoll，那么我们不需要进行任何额外的系统调用来唤醒循环，只需要将新任务放入队列中即可。
- 如果任何线程已经等待了几秒钟以上，它的堆栈就会变得混乱。然而，目前任务是在队列中循环调度的，所以除非没有工作在进行，否则这不是很有效。

* `::getEventBase()`将返回一个`EventBase`，您可以直接安排IO工作，默认的是round-robin。
* 因为每个线程只有一个队列，所以队列上几乎没有任何争用——所以任务使用一个围绕`std::deque` 的简单自旋锁。没有最大队列大小。
* 默认情况下，每个内核有一个线程——假设没有阻塞，拥有比这个更多的IO线程通常没有意义。

## CPU线程池

- 由folly/Lifosem和folly/MPMC队列支持的单个队列。因为只有一个队列，所以争用可能相当高，因为所有工作线程和所有生产者线程都在同一个队列中。MPMC队列在这种情况下表现出色。- -    -- MPMC队列规定了最大队列大小。
- LifoSem按照Lifo顺序唤醒线程——也就是说，只有很少的线程需要运行，我们总是试图重用相同的几个线程来获得更好的缓存局部性。
- 非活动线程的堆栈被搞乱了。这与Lifosem结合使用非常好——如果在启动时指定的线程超过了需要的数量，这几乎没有关系。
- stop()将在退出时完成所有未完成的任务支持优先级-优先级被实现为多个队列-每个工作线程首先检查最高优先级的队列。线程本身没有设置优先级，所以一系列长时间运行的低优先级任务仍然可能占据所有线程。(最后检查pthreads线程优先级是否工作得很好)

## 观察器

提供了一个观察器接口来监听线程启动/停止事件。这对于创建应该是每个线程一个的对象非常有用，但是如果在线程池中添加/删除线程，也可以使它们正常工作。

使用event_fd进行通知，并唤醒epoll循环。每个线程/epoll有一个队列(特别是通知队列)。如果线程已经在运行，并且没有在等待epoll，那么我们不需要进行任何额外的系统调用来唤醒循环，只需要将新任务放入队列中即可。如果任何线程已经等待了几秒钟以上，它的堆栈就会变得混乱。然而，目前任务是在队列中循环调度的，所以除非没有工作在进行，否则这不是很有效。因为每个线程只有一个队列，所以队列上几乎没有任何争用——所以任务使用一个围绕std::deque的简单自旋锁。没有最大队列大小。默认情况下，每个内核有一个线程——假设没有阻塞，拥有比这个更多的IO线程通常没有意义。

## noexcept

noexcept运算符执行编译时检查，如果声明表达式不引发任何异常，则该检查返回true。

它可以在函数模板的noexcept说明符中使用，以声明该函数将为某些类型引发异常，但不会为其他类型引发异常。

## std::chrono::steady_clock

类std::chrono::steady_clock代表单调时钟。该时钟的时间点不能随着物理时间向前移动而减少，并且该时钟的滴答之间的时间是恒定的。该时钟与挂钟时间无关(例如，它可以是自上次重新启动后的时间)，最适合测量时间间隔。

std::chrono::steady_clock符合TrivialClock的要求。

表示时钟持续时间内刻度数的算术类型

std::ratio类型，表示时钟的刻度周期，单位为秒

## MemoryIderTimeout

`MemoryIdlerTimeout` 类，如果事件循环在一段时间内没有使用，该类将释放jemalloc缓存，并销毁堆栈。

## explicit

1. 指定构造函数或转换函数(因为C++11)是显式的，也就是说，它不能用于隐式转换和复制初始化。
2. Explicit 说明符可以与constexpr一起使用。当且仅当constexpr的计算结果为真时，该函数才是显式的。(C++20特性)

Explicit 说明这个构造函数不能用作拷贝构造函数。



有趣的是在.h头文件中，类的属性和方法就已经声明好了，在.c文件中再具体写方法的实现。

实际上，C用得多了的话，方法就是一种特殊的函数，而类的声明实际上就是一种前置声明了。C++的这种设计就方面编译器去枚举这个类的所有方法了。在go语言中我们会在方法的函数签名中写对象的类型，而C++中我们用类作为命名空间去写方法的函数签名，方便汇编去找函数的实现。

## Pragma

该指令是一个特殊用途的指令，用于打开或关闭某些功能。这种类型的指令是特定于编译器的，即它们因编译器而异。下面讨论了一些#pragma指令:

1. `#pragma start`和`#pragma exit`: 这些指令帮助我们指定在程序启动之前(在控制权传递到main())和程序退出之前(在控制权从main()返回之前)需要运行的函数。
注意:下面的程序不适用于GCC编译器。
请看下面的程序:

2. `#pragma warn` Directive: 该指令用于隐藏编译期间显示的警告消息。当我们有一个大的程序，并且我们想在查看警告之前解决所有的错误，那么通过使用它，我们可以通过隐藏所有的警告来关注错误。我们可以通过语法上的细微变化让警告再次可见。
```cpp
#pragma warn +xxx (To show the warning)
#pragma warn -xxx (To hide the warning)
#pragma warn .xxx (To toggle between hide and show)
```
`#pragma warn -rvl`: 这个指令隐藏了那些当应该返回值的函数不返回值时引发的警告。
`#pragma warn -par`: 该指令隐藏了当函数不使用传递给它的参数时引发的警告。
`#pragma warn -rch`: 该指令隐藏了当代码不可访问时引发的警告。例如:在函数的return语句之后编写的任何代码都是不可访问的。

std::move用于指示一个对象t可以被“移出”，即允许将资源从t有效地转移到另一个对象。

特别是，std::move产生一个xvalue表达式来标识它的参数t。它完全等同于静态转换为右值引用类型。

当使用右值参数(prvalues，如临时对象或xvalues，如std::move产生的值)调用时，接受右值引用参数的函数(包括移动构造函数、移动赋值运算符和常规成员函数，如std::vector::push_back)通过重载解析进行选择。如果参数标识了一个拥有资源的对象，这些重载可以移动参数持有的任何资源，但不是必需的。例如，链表的移动构造函数可能会将指针复制到列表的头部，并将nullptr存储在参数中，而不是分配和复制单个节点。

右值引用变量的名称是左值，必须转换为xvalues才能绑定到接受右值引用参数的函数重载，这就是为什么move构造函数和move赋值运算符通常使用std::move:

使用`push_back(const T&)`重载，这意味着我们将承担复制字符串的成本

使用右值引用`push_back(T&&)`重载，这意味着不会复制任何字符串；相反，str的内容将被移动到向量中。这比较便宜，但也意味着字符串现在可能是空的。

典型的例子是vector的`push_back(T&&)`

`push_back(std::move(str))` 可以将字符串的数据直接改名字移动到vector中。

## lambda 表达式

1. 完整声明。

2. const lambda的声明:通过copy捕获的对象在lambda函数体中是常数。

3. 省略尾随(trailing)的返回类型:闭包运算符()的返回类型是从return语句中推导出来的，就像返回类型被声明为auto的函数一样。

4. 省略参数列表:函数不接受参数，就好像参数列表是()。
只有在不使用constexpr、mutable、exception specification、attributes或trailing return type的情况下，才能使用此表单。

Mutable 允许body修改由copy捕获的参数，并调用它们的非常量成员函数。

## pickThread

当新任务添加到IOThreadPoolExecutor时，会选择一个线程在其上执行，默认情况下会选择thisThread\_. 但是，如果新任务是通过线程销毁时的清理操作添加的，thisThread\_不再是可用线程，因此，在选择它之前，请始终检查thisThread\_是否是可用线程。

