# Wangle

这篇文章介绍了 wangle ，一个以异步、干净、可组合和可扩展的方式构建协议、服务器和客户端的C++库。 wangle 深受基于JVM的库Netty(一个Java网络应用框架)和Finagle(一个建立在Netty之上的在推特上的Scala RPC系统)的影响。 

wangle 的目标是为C++提供一套类似于Netty和Finagle为JVM所做的组合的抽象。 wangle 从2015年夏天开始开源，是几个 facebook 项目的稳定组成部分，包括开源fbthrift和Proxygen。我们将简要概述核心 wangle 组件，然后通过一个示例展示它们的威力。请注意，我们将专注于Netty-like的组件，而将非Netty-like的部分留给稍后的帖子。

wangle 建立在另外两个 facebook 开发的提供异步接口的库之上，这两个库都生活在我们的开源C++库中。

## 异步构建块

首先是`folly/io/async`，一组围绕libevent的面向对象异步IO包装器。`folly/io/async`提供事件基础、套接字(包括TCP套接字、UDP套接字、服务器套接字和SSL套接字)、异步超时/回调接口等。

其次是future，C++11的promise/future模式的实现。期货为表达异步计算提供了一种一元模式，它同时是高性能的、干净的和可组合的。

## 并发框架

### 线程池

 wangle 提供了一组有用的并发原语，其中最重要的是一对线程池实现——CPUThreadPoolExecutor和IOThreadPoolExecutor。出于几个原因，将绑定到输入输出的工作(例如异步套接字输入输出)与绑定到CPU的工作(例如应用程序业务逻辑)分开是很有用的。

首先，在像 wangle 这样的事件驱动服务器环境中，对于M &gt;&gt; N，M个连接通常跨N个IO线程多路复用，因为每个连接一个线程不能有效扩展(参见C10K问题)。

因此，重要的是，这些线程要尽可能少地阻塞，因为一个连接的每个工作周期都会阻塞该线程上托管的所有其他连接。因此，应用程序应该努力将长时间运行的工作或阻塞操作重新定位到一个独立的受CPU限制的线程池中，以减少尾部延迟。 wangle 让这变得容易，我们将在后面的例子中看到。

其次，线程池可以针对CPU绑定或IO绑定的工作负载进行优化，这就是为什么我们对每个工作负载都有单独的实现。对于IO池，线程不能共享单个epoll文件描述符，因为epoll_wait()会唤醒活动事件中的所有等待者，这将导致处理事件时的争用。相反，每个线程都有自己的epoll fd，因此也有自己的任务队列。这就排除了公平的调度，因为epoll_wait()调用没有办法协作，而是采用循环调度。

对于CPU池，我们可以做得更好。线程等待后进先出(LIFO)信号量，从多生产者、多消费者、无锁共享队列中拉出任务。后进先出信号量有几个理想的性能特征。首先，后进先出策略意味着尽可能少的线程在主动处理任务，从而增加缓存局部性。其次，我们的实现疯狂地去除了不活动线程的堆栈，这意味着可以相当自由地调整CPU池的大小，而不会占用过多的内存。此外，我们的CPU池通过多个共享队列支持任务优先级。

两个线程池都提供了许多有用的特性，包括每个池和每个任务的统计信息、池大小调整、任务到期(包括CoDel到期)、自定义线程工厂和线程事件观察器。

