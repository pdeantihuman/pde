# std::memory_order

std::memory_order指定如何围绕原子操作对内存访问进行排序，包括常规的、非原子的内存访问。在多核系统上没有任何约束的情况下，当多个线程同时读写多个变量时，一个线程可以观察到值的变化顺序不同于另一个线程写入它们的顺序。事实上，在多个读取器线程之间，更改的明显顺序甚至可能不同。由于内存模型允许的编译器转换，即使在单处理器系统上也可能出现类似的效果。

库中所有原子操作的默认行为提供了顺序一致的排序(参见下面的讨论)。该默认值可能会影响性能，但是库的原子操作可以被赋予一个额外的std::memory_order参数，以指定编译器和处理器必须为该操作强制执行的原子性之外的确切约束。

Relaxed操作:没有对其他读取或写入施加同步或排序约束，只有该操作的原子性得到保证(参见下面的宽松排序)

## 与 volatile 关键词的关系

在一个执行线程中，通过易失性glvalues进行的访问(读取和写入)不能在同一线程中之前或之后排序的可观察到的副作用(包括其他易失性访问)之后重新排序，但是这个顺序不能保证被另一个线程观察到，因为易失性访问不能建立线程间同步。

此外，易失性访问不是原子的(并发读写是一种数据竞争)，并且不排序存储器(非易失性存储器访问可以围绕易失性访问自由地重新排序)。

一个值得注意的例外是Visual Studio，在默认设置下，每个易失性写入都有释放语义，每个易失性读取都有获取语义(MSDN)，因此易失性可以用于线程间同步。标准易失性语义不适用于多线程编程，尽管它们足以用于例如与std::信号处理程序的通信，当应用于sig_atomic_t变量时，该处理程序在同一线程中运行。

## 用法

std::memory_order决定了一个原子变量的使用方式，类似 mysql 中的隔离等级。

```cpp
atomic_varible_.fetch_add(1, std::memory_order_relaxed)
```

