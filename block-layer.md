---
description: 这篇文章分析 Linux 块设备层。详细解释了 Linux 是如何处理块设备的。
---

# Linux 块设备

块设备是硬件设备，区别在于随机\(即，不一定是顺序\)访问固定大小的数据块。固定大小的数据块称为块。最常见的块设备是硬盘，但也存在许多其他块设备，如软盘驱动器、蓝光阅读器和闪存。请注意，这些都是安装文件系统的设备，文件系统是块设备的通用语言。

另一种基本类型的设备是字符设备。字符设备或字符设备作为连续数据流一个字节接一个字节地被访问。字符设备的例子有串口和键盘。如果硬件设备作为数据流被访问，则它被实现为字符设备。另一方面，如果设备是随机访问的\(非顺序\)，它就是块设备。

区别在于设备是否随机访问数据——换句话说，设备是否可以从一个位置寻找另一个位置。以键盘为例。作为驱动程序，键盘提供数据流。如果您键入wolf，键盘驱动程序会返回一个流，其中四个字母的顺序完全相同。无序阅读信件，或者阅读除了流中下一封之外的任何信件，都没有什么意义。键盘驱动器因此是充电设备；该设备提供用户在键盘上键入的字符流。从键盘上读取首先返回一个流，w，o，l，最后f。当没有按键等待时，该流为空。相反，硬盘驱动器则完全不同。硬盘驱动器可能要求读取一个任意块的内容，然后读取不同块的内容；这些块不必是连续的。硬盘的数据是随机存取的，而不是以流的形式；因此，硬盘是块设备。

管理内核中的块设备比管理角色设备需要更多的关注、准备和工作。字符设备只有一个位置——当前位置——而块设备必须能够在介质上的任何位置之间来回导航。事实上，内核并不需要提供一个专门用于管理角色设备的完整子系统，但是块设备正好接收到这个。这种子系统是必要的，部分原因是块设备的复杂性。然而，获得如此广泛支持的一个重要原因是块设备是相当性能敏感的；从硬盘中取出最后一滴比从键盘中挤出额外百分之一的速度要重要得多。此外，正如您将看到的，块设备的复杂性为这种优化提供了很大的空间。本章的主题是内核如何管理块设备及其请求。内核的这一部分被称为块输入输出层。有趣的是，修改块输入输出层是2.5开发内核的主要目标。本章涵盖了2.6内核中全新的块输入输出层。

## 块设备的解剖

块设备上最小的可寻址单元是扇区。扇区有两种不同的幂，但512字节是最常见的大小。扇区大小是设备的物理属性，扇区是所有块设备的基本单位——设备不能在小于扇区的单位上寻址或操作，尽管许多块设备可以同时在多个扇区上操作。大多数块设备有512字节的扇区，尽管其他大小也很常见。例如，许多光盘有2千字节的扇区。

软件有不同的目标，因此强加了它自己最小的逻辑可寻址单元，即块block。块是文件系统的抽象——文件系统只能以块的倍数访问。虽然物理设备可以在扇区级寻址，但是内核执行所有以块为单位的磁盘操作。因为设备的最小可寻址单元是扇区，所以块大小不能小于扇区，并且必须是扇区的倍数。

块设备在硬件上一般最小单位是扇区，在操作系统层面最小单位是块。扇区的大小 &lt; 块的大小 &lt; 页的大小。

此外，内核\(与硬件和扇区一样\)需要该块是二的幂。内核还要求块不大于页面大小\(参见第12章“内存管理”和第19章"可移植性"\)。因此，块大小是扇区大小的2的幂倍并且要小于页大小。常见的块大小为 512 B, 1KB, 4KB。

有些令人困惑的是，有些人用不同的名字来指代扇区和区块。扇区是设备最小的可寻址单元，有时被称为“硬扇区”或“设备块”同时，块，文件系统最小的可寻址单元，有时被称为“文件系统块”或“输入/输出块”本章继续称这两个概念为扇区和块，但是你应该记住其他术语。图14.1是扇区和缓冲器之间的关系图。 其他术语也很常见，至少在硬盘方面是如此——比如簇、圆柱体和磁头。这些概念只针对特定的块设备，并且在很大程度上对用户空间软件是不可见的。扇区对于内核来说之所以重要是因为在所有设备IO层面，所有的操作必须以扇区为单位。所以你的块概念是构建在扇区概念的基础上的。

当一个块存储在内存中时——比如说，在读或写挂起之后——它被存储在缓冲区中。每个缓冲区只与一个块相关联。缓冲区充当表示内存中磁盘块的对象。回想一下，一个块由一个或多个扇区组成，但大小不超过一页。因此，单个页面可以在内存中保存一个或多个块。因为内核需要一些相关的控制信息来伴随数据\(例如来自哪个块设备和缓冲区是哪个特定块\)，所以每个缓冲区都与一个描述符相关联。描述符被称为缓冲头，属于`struct buffer_head`类型。buffer\_head结构保存内核操作缓冲区所需的所有信息，并在`<linux/buffer_head.h>`.中定义。 看看这个结构，用注释描述每个字段:

```cpp
struct buffer_head{
    unsigned long b_state; // 缓冲区状态标志
    struct buffer_head *b_this_page; // 页面缓冲区列表
    struct page *b_page; // 关联页面
    sector_t b_blocknr; // 起始块数
    size_t b_size; // 映射的大小
    char *b_data; // 指向页面内数据的指针
    struct block_device *b_bdev;  // 关联的块设备
    bh_end_io_t *b_end_io; // 输入输出完成
    void *b_private; // 保留给 b_end_io
    struct list_head b_assoc_buffers; // 关联的映射
    struct address_space *b_assoc_map; // 关联地址空间
    atomic_t b_count; // 使用计数
};
```

`b_state`字段指定该特定缓冲区的状态。

它可以是表中的一个或多个标志。合法标志存储在`bh_state_bits`枚举中，该枚举在`<linux/buffer_head.h>`中定义。

表`bh_state`标志

| 状态 | 意义 |
| :--- | :--- |
| BH\_Uptodate | 缓冲区包含有效数据。 |
| BH\_Dirty | 缓冲区脏了。\(缓冲区的内容比磁盘上块的内容更新，因此缓冲区最终必须写回磁盘。\) |
| BH\_Lock | 缓冲区正在进行磁盘输入/输出，并被锁定以防止并发访问。 |
| BH\_Req | 输入输出请求中包含缓冲区。 |
| BH\_Mapped | 缓冲区是映射到磁盘块的有效缓冲区。 |
| BH\_New | 缓冲区是通过get\_block\(\)新映射的，尚未被访问。 |
| BH\_Async\_Read | 缓冲区正在通过`end_buffer_async_read()`异步读取输入/输出 |
| BH\_Async\_Write | 缓冲区正在通过`end_buffer_async_write()`异步写输入/输出 |
| BH\_Delay | 缓冲区还没有相关联的磁盘块\(延迟分配\)。 |
| BH\_Boundry | 缓冲区形成连续块的边界——下一个块是不连续的。 |
| BH\_Write\_EIO | 缓冲区在写入时发生输入/输出错误。 |
| BH\_Ordered | 有序写入。 |
| BH\_Eoptnotsupp | 缓冲区出现“不支持”错误。 |
| BH\_Unwritten | 磁盘上已分配了缓冲区空间，但实际数据尚未写出。 |
| BH\_Quiet | 抑制此缓冲区的错误。 |

