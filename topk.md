# TopK and GPU

许多数据分析工作负载中的常见操作是查找前k项，即根据某种排序顺序(通过SQL中的LIMIT或ORDER BY表达式实现)的最大或最小操作。top-k的一个天真的实现是对所有项目进行排序，然后返回第一个k，但是这比需要做的要多得多。虽然已经在传统多核处理器上探索了top-k的高效实现，但是还没有对GPU上的top-k实现进行过系统的研究，尽管在基于GPU的框架(如TensorFlow1和ArrayFire2)中对这种实现提出了开放的请求。在这项工作中，我们提出了几种针对GPu的top-k算法，包括一种基于二进制排序的新算法，称为二进制top-k。对于k值高达256的情况，二进制top-k算法比排序快15倍，比其他各种可能的实现快4倍。我们还开发了一个成本模型来预测我们的几种算法的性能，并表明它能准确预测现代图形处理器的实际性能。

一种常见的分析性SQL查询类型包括运行top-k，即在给定一个排序函数的情况下，找到n个元组中的最高(或最低)k。top查询的例子包括在电子商务网站上询问最贵的产品，在评论网站上询问最受好评的餐馆，或者在查询日志中询问性能最差的查询。Top-k是计算机科学，特别是数据管理中一个研究得很好的问题，因为top-k计算(按顺序/限制条款)实际上得到每个数据分析系统的支持。这个问题的例子很多，有效的解决方案也多种多样(调查见[13)。

寻找top-k元素的一种简单方法是对它们进行排序并返回第一个k。但是，排序做的工作比必要的多，因为不需要对top-k以外的元素进行排序。更好的方法是保持大小为k的优先级队列(也称为最大堆)，并在删除较小元素的同时插入较大的元素。这种方法的运行时间约为n个对数(k)。

通过逻辑分区数据，让每个处理器计算一个每个分区的top-k，并从m个每个分区的堆中计算全局top-k，可以在m个处理器上并行执行该算法。

虽然这种方法可以在多核处理器上有效实现(参见第6.7节)，但它不适合大规模并行系统的单指令多线程执行模型3。随着最近对基于GPU的查询处理[3，12，14，16，19，23]的兴趣，显然需要一种高效的大规模并行算法来解决top-k问题。

事实上，我们发现两个最主流的GPU编程框架(Tensorflow和Arrayfire) [1，2]都有添加top-k运算符的开放功能请求。一种为这个问题的解决方案的存在甚至特征发展直觉的方法是考虑top-k和排序算法的双重性。我们在图1中说明了这种二元性:对应于优先级队列的排序算法是heapsort。事实上，我们可以将heapsort看作是一个k = n的优先级队列的构造，以及随后按排序顺序提取元素。当然，这隐藏了许多实现细节，但有助于形成直觉。当考虑大规模并行体系结构中的排序和top-k时，人们会发现教科书中的大规模并行排序算法是二进制排序。然而，没有已知的对应于二进制排序的top-k算法。

## GPU 与 多线程性能对比

在本节中，我们比较了基于CPU的top-k和基于GPU的top-k的性能。对于基于CPU的top-k，我们有两种基于堆的方法:一种是使用C++ STL优先级队列作为最小堆(`STLPQ`)，另一种是手动优化的最小堆(Hand PQ)。对于每个元素，我们通过与堆的根进行比较，对照堆最小值来检查它。如果它更大，我们弹出根(最小值)并插入新元素。我们还展示了bitonic top-k的CPU版本。对于基于GPU的top-k，我们展示了`Bitonic TopK`和`Radix Select`。

首先，我们在从均匀分布$U(0,1)$中提取的$2^{29}$个浮点数据集中比较它们。图15(a)显示了结果。由于数据是均匀分布的，当对照堆最小值进行检查时，大多数元素被丢弃，很少元素触发堆插入。为了说明这一点，对于这个`k = 32`的数据集，每个内核查看671k个元素，最后进行大约500次插入(包括总是被插入的前32个元素)。因此，性能可能受内存限制。当k = 32时，`Bitonic TopK`比`Hand PQ`好3倍。CPU上的bitonic top-k比基于堆的方法差得多，因为它比仅执行500次插入的基于堆的方法计算量大得多。

接下来，我们考虑相同的数据集，但按递增顺序排序。图15(b)显示了结果。由于数据已排序，每个元素都会导致堆弹出/插入。这接近最坏的情况。Bitonic TopK和Radix Select占用的时间相同，而CPU算法的性能明显更差。当k = 32时， Bitonic TopK比`Hand PQ`好60倍，比`STLPQ`好120倍。尽管做了更多的比较，但bitonic top-k在CPU上所花费的时间与`Hand PQ`相近。这是由于使用了SIMD指令。

如本节中的经验所示，对于较小的K (K ≤ 256)和较大的K，Bitonic TopK是最佳性能方法。为了提供支持这些发现的分析论据并预测不同硬件上的性能，我们在第7节中开发了硬件意识成本模型。