# 对 RedLock 的分析

分布式系统研究员马丁·克莱普曼\(Martin Kleppmann\)昨天发表了一份对Redlock的分析\([http://redis.io/topics/distlock](http://redis.io/topics/distlock)\)，你可以在这里找到:[http://Martin.Kleppmann.com/2016/02/08/how-do-distributed-lock.html](http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)

Redlock是我设计用于Redis的客户端分布式锁算法，但是该算法在客户端协调一组实现具有特定功能的数据存储的节点，以便创建一个具有自动释放功能的，多Master容错的、希望是安全的分布式锁。 例如，您可以使用MySQL而不是Redis来实现Redlock。

该算法的目标是将使用单个Redis实例或具有故障转移的主从设置的人转移到更可靠和安全的地方，但复杂性非常低且性能良好。

自从我发表 RedLock 以来，人们用多种语言实现了它，并将其用于不同的目的。

马丁对算法的分析得出结论，Redlock是不安全的。马丁发表了一份分析报告，这很好，我在这里要求在原始的 RedLock 规范中进行分析:[http://redis.io/topics/distlock](http://redis.io/topics/distlock)，谢谢你，马丁。然而我不同意这个分析。好的一面是，与其他编程领域不同，分布式系统在数学上非常精确，或者不是，所以给定的一组属性可以通过算法来保证，或者算法在某些假设下可能无法保证它们。在这个分析中，我将分析马丁的分析，以便该领域的其他专家可以检查这两个文件\(分析和反分析\)，最终我们可以理解RedLock是否被认为是安全的。

马丁为什么认为雷德洛克不安全 -

分析中的论点主要有两个:

1. 具有自动释放功能的分布式锁\(互斥锁属性仅在获取锁后的固定时间内有效\)需要一种方法来避免客户端在过期时间后使用锁时出现问题，从而在访问共享资源时违反互斥。马丁说雷德洛克没有这样的机制。
2. 马丁说，不管问题“1”，该算法本质上是不安全的，因为它对系统模型做出了在实际系统中无法保证的假设。

为了清楚起见，我将从第一个“1”开始分别解决这两个问题。

## 分布式锁、自动释放和令牌

没有自动释放机制的分布式锁基本上是无用的，在这种机制下，锁所有者将无限期地持有它。如果持有锁的客户端崩溃，并且在短时间内无法以完整状态恢复，则会创建死锁，分布式锁试图保护的共享资源将永远无法访问。这产生了一个在大多数情况下不可接受的活性问题，因此一个健全的分布式锁必须能够自动释放自己。

因此，实用的锁为客户提供了最长的生存时间。过期后，互斥保证这个锁的 \*main\* 属性就消失了: 
另一个客户端可能已经拥有了锁。如果两个客户端在两个不同的时间获取锁，但是第一个客户端速度太慢，因为垃圾回收暂停或其他调度问题，会尝试与获取锁的第二个客户端同时在共享资源的上下文中工作，会发生什么情况？

马丁说，这个问题可以通过分布式锁服务器为每个锁提供一个令牌来避免，在他的例子中，令牌只是一个保证总是递增的数字。马丁使用令牌的基本原理是，这样，当两个不同的客户端同时访问锁定的资源时，我们可以在数据库写事务中使用令牌\(假设实现了客户端所做的工作\):只有锁号最大的客户端才能写入数据库。

用马丁的话说:

> “这个问题的解决实际上非常简单:您需要在对存储服务的每个写请求中包含一个隔离令牌。在这种情况下，隔离令牌只是一个数字，每当客户端获取锁时，该数字就会增加\(例如，由锁服务增加\)

... ...

请注意，这要求存储服务器在检查令牌和拒绝令牌向后移动的任何写入时发挥积极作用。

我认为这个论点有很多问题:

1. 大多数时候，当你需要一个分布式锁系统来保证互斥性时，当这个属性被侵犯时，你已经丢失了。当我们在共享资源中没有其他控制时，分布式锁非常有用。在他的分析中，马丁假设当锁的互斥性被违反时，你总是有其他方法来避免竞争条件。我认为这是一种非常奇怪的方法来推理具有强保证的分布式锁，不清楚如果你能以不同的方式解决种族问题，为什么你会使用具有强属性的锁。然而，我将继续下面的其他观点，仅仅是为了表明Redlock可以在这个非常人工的环境中很好地工作。
2. 如果只有当您的令牌大于所有过去的令牌时，您的数据存储才能始终接受写入，那么它就是一个可线性化的存储。如果您有一个可线性化的存储，您只需为每个获取的Redlock生成一个增量标识，因此这将使Redlock等同于为每个新锁提供增量令牌标识的另一个分布式锁系统。然而在下一点，我将展示这是如何不需要的。
3. 然而“2”无论如何都不是一个明智的选择:大多数情况下，使用共享资源的结果不是写入可线性化的存储，那么该怎么办？每个Redlock都与一个大的随机令牌相关联(它是以可以忽略冲突的方式生成的)。Redlock规范的文本假设为“来自/dev/urandom的20字节”。你用一个独特的令牌做什么？例如，您可以实现检查和设置。当开始使用共享资源时，我们将其状态设置为“`&lt;令牌&gt;”，然后只有当令牌在写入时仍然相同时，我们才操作读-修改-写入。
4. 请注意，在某些用例中，可以说，订购令牌无论如何都是有用的。虽然在用例中很难思考，但是请注意，对于马丁提到的同一个GC暂停，令牌的获取顺序并不一定尊重客户端尝试处理共享资源的顺序，因此锁定顺序可能不会随随便便地与处理共享资源的效果相关联。
5. 大多数情况下，锁用于访问以非事务性方式更新的资源。例如，有时我们使用分布式锁来移动物理对象。或者与另一个外部应用编程接口交互，等等。

我想再提一次，奇怪的是，这一切都是假设你总是有办法处理相互排斥被违反的事实。实际上，如果你有这样一个系统来避免在比赛条件下出现问题，你可能根本不需要分布式锁，或者至少你不需要有强保证的锁，而只需要一个弱锁来避免大多数情况下由于性能原因的并发访问。

然而，即使你碰巧同意马丁的观点，上面的事实非常有用，底线是每个锁的唯一标识符可以用于相同的目标，但是在不需要商店的强有力保证方面更实用。