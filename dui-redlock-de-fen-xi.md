# 对 RedLock 的分析

分布式系统研究员马丁·克莱普曼\(Martin Kleppmann\)昨天发表了一份对Redlock的分析\([http://redis.io/topics/distlock](http://redis.io/topics/distlock)\)，你可以在这里找到:[http://Martin.Kleppmann.com/2016/02/08/how-do-distributed-lock.html](http://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html)

Redlock是我设计用于Redis的客户端分布式锁算法，但是该算法在客户端协调一组实现具有特定功能的数据存储的节点，以便创建一个具有自动释放功能的，多Master容错的、希望是安全的分布式锁。 例如，您可以使用MySQL而不是Redis来实现Redlock。

该算法的目标是将使用单个Redis实例或具有故障转移的主从设置的人转移到更可靠和安全的地方，但复杂性非常低且性能良好。

自从我发表 RedLock 以来，人们用多种语言实现了它，并将其用于不同的目的。

马丁对算法的分析得出结论，Redlock是不安全的。马丁发表了一份分析报告，这很好，我在这里要求在原始的 RedLock 规范中进行分析:[http://redis.io/topics/distlock](http://redis.io/topics/distlock)，谢谢你，马丁。然而我不同意这个分析。好的一面是，与其他编程领域不同，分布式系统在数学上非常精确，或者不是，所以给定的一组属性可以通过算法来保证，或者算法在某些假设下可能无法保证它们。在这个分析中，我将分析马丁的分析，以便该领域的其他专家可以检查这两个文件\(分析和反分析\)，最终我们可以理解RedLock是否被认为是安全的。

马丁为什么认为雷德洛克不安全 -

分析中的论点主要有两个:

1.具有自动释放功能的分布式锁\(互斥锁属性仅在获取锁后的固定时间内有效\)需要一种方法来避免客户端在过期时间后使用锁时出现问题，从而在访问共享资源时违反互斥。马丁说雷德洛克没有这样的机制。

2.马丁说，不管问题“1”，该算法本质上是不安全的，因为它对系统模型做出了在实际系统中无法保证的假设。

为了清楚起见，我将从第一个“1”开始分别解决这两个问题。

分布式锁、自动释放和令牌 -

没有自动释放机制的分布式锁基本上是无用的，在这种机制下，锁所有者将无限期地持有它。如果持有锁的客户端崩溃，并且在短时间内无法以完整状态恢复，则会创建死锁，分布式锁试图保护的共享资源将永远无法访问。这产生了一个在大多数情况下不可接受的活性问题，因此一个健全的分布式锁必须能够自动释放自己。

因此，实用的锁为客户提供了最长的生存时间。过期后，互斥保证\(锁的_main_属性\)就消失了:另一个客户端可能已经拥有了锁。如果两个客户端在两个不同的时间获取锁，但是第一个客户端速度太慢，因为垃圾回收暂停或其他调度问题，会尝试与获取锁的第二个客户端同时在共享资源的上下文中工作，会发生什么情况？

马丁说，这个问题可以通过分布式锁服务器为每个锁提供一个令牌来避免，在他的例子中，令牌只是一个保证总是递增的数字。马丁使用令牌的基本原理是，这样，当两个不同的客户端同时访问锁定的资源时，我们可以在数据库写事务中使用令牌\(假设实现了客户端所做的工作\):只有锁号最大的客户端才能写入数据库。

用马丁的话说:

“这个问题的解决实际上非常简单:您需要在对存储服务的每个写请求中包含一个隔离令牌。在这种情况下，隔离令牌只是一个数字，每当客户端获取锁时，该数字就会增加\(例如，由锁服务增加\)

…剪…

请注意，这要求存储服务器在检查令牌和拒绝令牌向后移动的任何写入时发挥积极作用。

我认为这个论点有很多问题:

1.大多数时候，当你需要一个分布式锁系统来保证互斥性时，当这个属性被侵犯时，你已经丢失了。当我们在共享资源中没有其他控制时，分布式锁非常有用。在他的分析中，马丁假设当锁的互斥性被违反时，你总是有其他方法来避免竞争条件

